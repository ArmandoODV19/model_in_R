---
title: 'Modelos de estadística clásica: muestreos aleatorios'
author: "Armando Ocampo"

output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Librerías de trabajo

Para esta clase necesitamos cargar las siguientes librerias

```{r trabajo, echo=TRUE, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)

```


## Dudas de la clase previa

### Recodificar NA's

Los NA's son valores faltantes o no disponibles, los cuales suelen representar un problema durante la transformación y procesamiento de los datos. Por lo cual, previo a realizar cualquier análisis o función sobre el dataset es necesario conocer el comportamiento de nuestros datos. Para esto utilizaremos la función *summary()* de la paquetería *base* (Esta paquetería se encuentra instalada por defecto en el lenguaje de programación R, por lo cual no es necesario instalarla).

Generaremos un data frame con valores NA.

```{r dummy, echo=TRUE}
dummy_data <- data.frame(id=c(1,2,3,4,NA),
              horas_estudio=c(2, 5, 4, 2, 1),
              horas_recre=c(4, 2, 4, 3, 1),
              edad = c(20, 15, 16, 22, 20))

summary(dummy_data)
```

Además de algunas medidas de estadísitca descriptiva, esta función detalla si existen NA's en nuestro dataset. Otra manera de conocer si existen o no NA's es mediante la función *is.na()*. Esta generará como resultado TRUE, en el sitio donde encuentre un resultado faltante.

```{r dummy_2, echo=TRUE}
is.na(dummy_data)

# podemos acompañarlo con la función sum(), para saber el total de NA's 
sum(is.na(dummy_data))

# También, es posible utilizar la función which() para determinar el sitio
# en la columna donde se encuentra el NA. En este caso, conocemos que el NA 
# se encuentra en la columna id, ahora identificaremos su posición

which(is.na(dummy_data$id))

# Es así, como determinamos qué el valor faltante se encuentra en el quinto
# lugar de la columna id
```

Otra manera es utilizar la función *sapply()* acompañado de la función *sum()* para determinar el total de NA's por columna

```{r dummy3, echo=TRUE}
sapply(dummy_data, function(y) sum(length(which(is.na(y)))))
```

Estas son algunas maneras de identificar los valores faltantes. A continuación, se mostrarán algunos métodos para su eliminación.

El primer método es la recodificación, en el cual se le agrega un valor concreto al NA. Esto, al colocar la posición en la que se encuentra y renombrarla. En este caso, al ver la numeración, suponemos que el id faltante es el numero 5.

```{r dummy4, echo=TRUE}
dummy_data$id[is.na(dummy_data$id)] = 5
dummy_data
```

Vamos a generar de nuevo el valor NA. Sin embargo, en el siguiente ejemplo utilizaremos la función *na.omit()* para quitar el valor faltante. Esta función se caracteriza por eliminar la fila donde se encuentra el valor NA.

```{r dummy5, echo=TRUE}
dummy_data <- data.frame(id=c(1,2,3,4,NA),
              horas_estudio=c(2, 5, 4, 2, 1),
              horas_recre=c(4, 2, 4, 3, 1),
              edad = c(20, 15, 16, 22, 20))

na.omit(dummy_data)
```

**Nota: *na.omit()* puede ser funcional si la recodificación no es posible. No obstante, hay que tener cuidado en no eliminar la mayor parte de la información. Esto lo veremos a continuación**

Si tenemos varios NA a lo largo del dataset, *na.omit()* puede ser contraproducente. El siguiente ejemplo lo detalla.

```{r dummy6, echo=TRUE}
dummy_data_2 <- data.frame(id=c(1,2,3,4,NA,6,7,8,9,10,11,12),
                           horas_estudio=c(NA,5,4,2,1,3,NA,2,4,3,5,NA),
                           horas_recre=c(9,NA,8,3,NA,8,5,6,8,NA,4,7),
                           edad = c(20,15,NA,22,NA,17,18,NA,18,20,18,15))

# contando NA's por columna
sapply(dummy_data_2, function(y) sum(length(which(is.na(y)))))
```

Al aplicar la función *na.omit()* perdemos la mayor parte de la información

```{r dummy7, echo=TRUE}
na.omit(dummy_data_2)
```

Para este caso, podemos hacer dos maneras de recodificación. Colocar un 0 en todos los NA's, o definir un valor específico por columna.

```{r dummy8, echo=TRUE}
dummy_data_2 <- data.frame(id=c(1,2,3,4,NA,6,7,8,9,10,11,12),
                           horas_estudio=c(NA,5,4,2,1,3,NA,2,4,3,5,NA),
                           horas_recre=c(9,NA,8,3,NA,8,5,6,8,NA,4,7),
                           edad = c(20,15,NA,22,NA,17,18,NA,18,20,18,15))

dummy_data_2[is.na(dummy_data_2)] = 0

dummy_data_2

```

Para el segundo caso, colocaremos el valor de la media aritmética por columna para el proceso de recodificación.

```{r dummy9, echo=TRUE}
dummy_data_2 <- data.frame(id=c(1,2,3,4,NA,6,7,8,9,10,11,12),
                           horas_estudio=c(NA,5,4,2,1,3,NA,2,4,3,5,NA),
                           horas_recre=c(9,NA,8,3,NA,8,5,6,8,NA,4,7),
                           edad = c(20,15,NA,22,NA,17,18,NA,18,20,18,15))

mean(dummy_data_2$horas_estudio, na.rm = TRUE)
dummy_data_2$horas_estudio[is.na(dummy_data_2$horas_estudio)]=2.4

mean(dummy_data_2$horas_recre, na.rm = TRUE)
dummy_data_2$horas_recre[is.na(dummy_data_2$horas_recre)] = 4.8

mean(dummy_data_2$edad, na.rm = TRUE)
dummy_data_2$edad[is.na(dummy_data_2$edad)] = 13

dummy_data_2
```

**Nota: es posible combinar métodos de recodificación. Todo depende del objetivo de la limpieza del conjunto de datos**

## Identificando cuartiles

Los cuartiles dividen al conjunto de datos en 4 grupos, a partir de 3 puntos de corte. Primer cuartil (Q1, 25%), segundo cuartil (Q2, 50%), tercer cuartil (Q3, 75%). Derivado de esta información, podemos definir en que sitio se puede encontrar un dato nuevo. Los siguientes son solo ejemplo de cómo realizarlo, ya que pueden existir varias maneras de hacerlo.

Primero identificaremos los cuartiles de la longitud del sépalo del dataset iris

```{r cuartiles, echo=TRUE}
quantile(iris$Sepal.Length)

```

La siguiente función genera un mensaje dependiendo del sitio en el cual se encuentra el nuevo valor

```{r cuantiles2, echo=TRUE}
identificando_cuartiles <- function(x){
  if(x <= 5.1) print('debajo Q1')
  if(x > 5.1 & x <= 5.8) print('entre Q1 y Q2')
  if(x >5.8 & x <= 6.4) print('entre Q2 y Q3')
  if(x > 6.4) print('superior a Q3')
}

identificando_cuartiles(6.5)
```

La función *case_when()* de la paquetería *dplyr* permite generar condiciones similares a las utilizadas en la función *if()*. Cuando se utiliza en conjunto a la función *mutate()*, los resultados se guardan en una columna nueva.

```{r cuantiles3, echo=TRUE}
iris_df <- iris

quantile(iris_df$Sepal.Length)

iris_df_cuartil <- iris_df %>%
  mutate(cuartil = case_when(Sepal.Length <= 5.1 ~ '< Q1',
                             Sepal.Length > 5.1 & Sepal.Length <= 5.8 ~ 'Q1 & Q2',
                             Sepal.Length > 5.8 & Sepal.Length <= 6.4 ~ 'Q1 & Q3',
                             Sepal.Length > 6.4 ~ '> Q3'))

head(iris_df_cuartil)
```

De esta manera, se puede colocar una variable nueva, pegarla al dataset y conocer en que cuartil se encuentra.

```{r cuartiles4, echo=TRUE}
iris_df <- iris
iris_nueva <- c(5.222,NA,NA,NA,NA)

new_iris <- rbind(iris_nueva, iris_df)

head(new_iris %>%
       mutate(cuartil = case_when(Sepal.Length <= 5.1 ~ '< Q1',
                                             Sepal.Length > 5.1 & Sepal.Length <= 5.8 ~ 'Q1 & Q2',
                                             Sepal.Length > 5.8 & Sepal.Length <= 6.4 ~ 'Q1 & Q3',
                                             Sepal.Length > 6.4 ~ '> Q3')),1)
```

## Muestreo

Cuando el conjunto de datos es grande y representa un elevado costo económico y de tiempo máquina se recomienda utilizar muestras. Estas deben de ser aleatorias y representativas. Los estadísticos obtenidos se pueden generalizar e inferir el comportamiento de la población. En R, existen dos funciones que permiten realizar este proceso, *sample()* y *slice_sample()*. La función *sample()* forma parte de la paquetería *base*, y se utiliza para encontrar muestras de vectores. Por su parte, la función *slice_sample()* pertenece a la paquetería *dplyr* y funciona para obtener muestras de data frames.

**Nota: debido a que las muestras se realizan "al azar", es necesario definir un parámetro que permita replicar los resultados cuando se trabaja en grupos o para verificar la información. Para esto, se utiliza la función *set.seed()* antes de comenzar a trabajar**

En el siguiente ejemplo, se generará un vector con numeros del 1 al 100000. Posteriormente, se tomará una muestra de 20000 numeros. Dentro de la función *sample()*, se coloca como primer argumento el vector del cual se va a extraer la información y el segundo argumento indica el tamaño de la muestra.

```{r muestra, echo=TRUE}
set.seed(123)
vectorcito <- seq(1, 100000, by = 1)

vectorcito_muestra <- sample(vectorcito, size = 20000)

length(vectorcito_muestra)

```

Por su parte, *slice_sample()*, permite obtener una muestra de un data frame. El siguiente ejemplo extraerá 100 elementos al azar del conjunto de datos iris.


```{r muestra2, echo=TRUE}
set.seed(123)
iris_muestra <- slice_sample(iris, n = 100)

summary(iris_muestra)
summary(iris)
```













